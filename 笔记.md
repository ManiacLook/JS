[toc]

# JS 基础

## 1.简介

​	ECMAScript 是 JavaScript 标准

​	一个完整的 JavaScript 应该包含三个部分：

- ECMAScript（标准）
- DOM
- BOM

## 2.JS的编写位置

### 2.1.编写标签的指定属性中

```javascript
<button onclick="alert('点按钮');">点我一下</button>
<a href="javascript:alert('点超链接');">点我一下</a>
```

### 2.2.编写到script标签中

```javascript
<script type="text/javascript">  
	//编写js代码  
</script>
```

### 2.3.编写到外部的js文件中，然后通过标签将其引入

```javascript
<script type="text/javascript" src="../js/script.js"></script>
```

## 3.基本语法

* js中严格区分大小写

* js中每一条语句以分号结尾，若不写分号，浏览器会消耗资源进行添加，且有些时候会加错分号

* js会忽略多个空格和换行，可以利用空格和换行对代码进行格式化

## 4.字面量和变量

​	字面量是不可改变的值，比如常量12

​	变量可用来改变字面量，且变量的值可以任意改变

```javascript
// 声明变量
var a;
// 为变量赋值
a = 12;
```

## 5.标识符

​	在 JS 中所有的可以自主命名的内容，都可以认为是一个标识符，是标识符就应该遵守标识符的规范。

​	比如：变量名、函数名、属性名

规范：

* 标识符中可以含有字母、数字、_、$

* 标识符不能以数字开头

* 标识符不能是JS中的关键字和保留字

* 标识符一般采用驼峰命名法，首字母小写，每个单词的开头字母大写，其余字母小写 xxxYyyZzz

* js底层保存标识符时实际上是采用的Unicode编码，理论上所有utf-8含有的内容都可以作为标识符

# 数据类型

## 1.六种数据类型

​	数据类型指的就是字面量的类型

* String 字符串

* Number 数值

* Boolean 布尔值

* Null 空值

* Undefined 未定义

* Object 对象

  其中String、Number、Boolean、Null、Undefined属于<font color='red'>基本数据类型</font>，Object属于<font color='red'>引用数据类型</font>

  typeof <font color='red'>返回数据类型</font>

### 1.1.String 字符串

​	 JS中的字符串需要使用引号引起来，双引号或单引号都行，在字符串中使用\作为转义字符

```javascript
\'  ==> '  
\"  ==> "  
\n  ==> 换行  
\t  ==> 制表符  
\\  ==> \
```

### 1.2.Number 数值

​	JS中所有的<font color='red'>整数</font>和<font color='red'>浮点数</font>都是Number类型，进行浮点运算时可能不精确

* 最大能表示的值，Number.MAX_VALUE= 1.7976931348623157e+308

* Infinity 正无穷，超过最大值时返回Infinity
* NaN 非法数字（Not A Number）
* Number.MIN_VALUE 大于0的最小值
* 使用typeof检查一个Number类型的数据时，会返回 ”number”

* 其他进制的数字

  0b 开头表示二进制，但是不是所有的浏览器都支持
  0 开头表示八进制
  0x 开头表示十六进制

  ```javascript
  var a = 0x10; // 16
  a = 020; // 16
  a = 0b11; // 3
  ```

  

### 1.3.Boolean 布尔值

​	布尔值主要用来进行逻辑判断，布尔值只有两个

* true 逻辑的真
* false 逻辑的假
* 使用typeof检查一个布尔值时，会返回”boolean”

### 1.4.Null 空值

* null 用来表示为空的对象，Null类型的值只有一个null
* 使用typeof检查一个Null类型的值时会返回”object”

### 1.5.Undefined 未定义

* 当声明一个变量，但不给变量赋值时，其值就是undefined 

### 1.6.引用数据类型

​	Object 对象

## 2.类型转换

​	类型转换就是指将其他的数据类型，转换为String Number 或 Boolean

### 2.1.转换为String

**方式一**

​	调用toString()方法，该方法不会影响到原变量，会将转换的结果返回，不适用于null和undefined

```javascript
var a = 123;
var b = a.toString();
```

**方式二**

​	调用String()

​              对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串

​              对于null值，直接转换为字符串"null"

​              对于undefined直接转换为字符串"undefined"

**方式三**

​	任意数据类型+""可以转换为String，实际上是调用String()函数

             ```javascript
             var a = true; 
             a = a + ""; // "true"
             ```

### 2.2.转换为number

**方式一**

​	调用 Number() 

​		（1）字符串 > 数字

​              如果字符串是一个合法的数字，则直接转换为对应的数字

​              如果字符串是一个非法的数字，则转换为NaN

​              如果是一个空串或纯空格的字符串，则转换为0

​		（2）布尔值 > 数字

​              true转换为1

​              false转换为0

​		（3）空值 > 数字

​              null转换为0

​		（4）undefined > 数字

​              undefined转换为NaN

**方式二**

* parseInt() 专门用来将一个字符串转换为整数，可以将一个字符串中的有效的整数位提取出来，并转换为Number，可以传递第二个参数，指定数字的进制
* parseFloat() 专门用来将一个字符串转换为浮点数
* 如果对非 String 使用 parseInt() 或 parseFloat()，它会先将其转换为 String 然后在操作 parseInt()

**方式三**

​	隐式类型转换：-0、*1、/1、+a

```javascript
var result = "10" - 0;
```

### 2.3.转换为布尔值

**方式一**

​	调用Boolean()

​			数值 ---> 布尔

​              	除了0和NaN其余的全是true

​            字符串 ---> 布尔

​              	除了空串其余全是true

​            null、undefined ---> 布尔

​              	都是false

​            对象 ---> 布尔

​              	都是true

**方式二**

​	为任意的数据类型做两次非运算，即可将其转换为布尔值

```javascript
var a = "hello";  
a = !!a; //true
```

# 基础语法

## 1.运算符

​	运算符也称为操作符，通过运算符可以对一个或多个值进行运算或操作。

### 1.1.typeof

​	用来检查一个变量的数据类型，它会返回一个用于描述类型的字符串作为结果

```javascript
typeof 变量
```

### 1.2.算术运算符

- +对两个值进行加法运算并返回结果

​            如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。

​            任何值和字符串做加法，都会先转换为字符串，然后再拼串(可利用这个进行隐式转换String)

- -对两个值进行减法运算并返回结果
- *对两个值进行乘法运算并返回结果
- /对两个值进行除法运算并返回结果
- %对两个值进行取余运算并返回结果

- 任何值和NaN做运算都得NaN

- 除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后再做运算(可利用这个进行隐式转换Number)

```javascript
var a = 123;
var result = a + 1;
result = true + 1; // 2
result = "123" + "456"; // 123456
result = "hhaha" + 666; // hhaha666
result = 1 + 2 + "3"; // 33
result = "1" + 2 + 3; // 123
result = 100 - "1"; // 99
result = 2 * "8"; // 16
result = 2 * undefined; // NaN
result = 2 * null; // 0
result = "10" - 0; // number，也可以*1、/1
```

### 1.3.一元运算符

​	一元运算符只需要一个操作数

（1）\+ 正号

​        不会对值产生任何影响，但是可以将一个非数字转换为数字

​        可以对非number用+，转换为number

（2）\- 负号

​        对一个数字进行符号位取反

（3）自增 ++

​		使变量在原值的基础上自增1，自增可以使用 前++（++a）后++(a++)

​		无论是++a 还是 a++都会立即使原变量自增1

​        ++a的值是变量的新值（自增后的值），a++的值是变量的原值（自增前的值）

（4）自减 --

​          使变量在原值的基础上自减1

​          自减可以使用 --a 和 a--，无论是 --a 还是 a-- 都会立即使原变量自减1

​          --a 的值是变量的新值（自减后的值），a-- 的值是变量的原值（自减前的值）

### 1.4.逻辑运算符

（1）!

​		! 对一个布尔值进行取反，true变false,false变true

​        当对非布尔值使用!时，会先将其转换为布尔值然后再取反

​        可以利用!!来将其他的数据类型转换为布尔值

（2）&&

​          && 对符号两侧的值进行与运算

​          只有两端的值都为true时，才会返回true。只要有一个false就会返回false。

​          与是一个短路的与，如果第一个值是false，则不再检查第二个值

​          对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值

​          规则：

​            1.如果第一个值为false，则返回第一个值

​            2.如果第一个值为true，则返回第二个值

（3）||

​          || 对符号两侧的值进行或运算

​          只有两端都是false时，才会返回false。只要有一个true，就会返回true。

​          或是一个短路的或，如果第一个值是true，则不再检查第二个值

​          对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值

​          规则：

​            1.如果第一个值为true，则返回第一个值

​            2.如果第一个值为false，则返回第二个值

### 1.5.赋值运算符

（1）=

​          可以将符号右侧的值赋值给左侧变量

（2）+=

​          a += 5 相当于 a = a+5  

​          var str = "hello"; str += "world";

（3）-=

​          a -= 5 相当于 a = a-5

（4）*=

​          a *= 5 相当于 a = a*5

（5）/=

​          a /= 5 相当于 a = a/5

（6）%=

​          a %= 5 相当于 a = a%5

### 1.6.关系运算符

​		关系运算符用来比较两个值之间的大小关系的

​        包括 \>、>=、<、<=

​        关系运算符的规则和数学中一致，用来比较两个值之间的关系，如果关系成立则返回true，关系不成立则返回false。

​        如果比较的两个值是非数值，会将其转换为Number然后再比较。

​        如果比较的两个值都是字符串，此时会比较字符串的Unicode编码(逐位进行比较，若两位相同，则比较下一位)，而不会转换为Number。

### 1.7.编码

```javascript
/*
    在字符串中使用转义字符输入unicode编码
    \u四位编码
*/
console.log("\u0031");
console.log("\u2620");
```

```html
<!-- 在网页中使用unicode编码
	&#编码; 这里的编码需要10进制
-->
<h1 style="font-size:100px">&#9760;</h1>
```

### 1.8.相等运算符

（1）==

​	判断左右两个值是否相等，如果相等返回true，如果不等返回false

​    == 会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true，null == undifined

（2）!=

​          判断左右两个值是否不等，如果不等则返回true，如果相等则返回false

​          会做自动的类型转换

（3）===

​          全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，

​          如果两个值的类型不同，则直接返回 false

（4）!==

​          不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true

（5）特殊的值：

​        null和undefined

​            由于undefined衍生自null，所以null == undefined 会返回true。

​            但是 null === undefined 会返回false。

​        NaN

​          NaN不与任何值相等，包括它自身 NaN == NaN // false

​          判断一个值是否是 NaN 使用 isNaN() 函数

### 1.9.三元运算符

```javascript
条件表达式 ? 语句1 : 语句2;
```

​	先对条件表达式求值判断，

​            如果判断结果为 true，则执行语句1，并返回执行结果

​            如果判断结果为 false，则执行语句2，并返回执行结果

### 1.10.运算优先级

​	越靠上的优先级越高

![image-20210928120155721](C:\Users\LOOK\AppData\Roaming\Typora\typora-user-images\image-20210928120155721.png)

​	优先级不需要记忆，如果越到拿不准的，使用 () 来改变优先级

## 2.流程控制语句

### 2.1.条件分支语句

```javascript
if(条件表达式){  
	语句...  
}else if(条件表达式){  
	语句...  
}else if(条件表达式){  
	语句...  
}else if(条件表达式){  
	语句...  
}else{  
	语句...  
}
```

```javascript
switch(条件表达式){  
	case 表达式:  
		语句...  
		break;  
	case 表达式:  
		语句...  
		break;  
	case 表达式:  
		语句...  
		break;  
	default:  
		语句...  
		break;  
}
```

### 2.2.循环语句

（1）while 循环

```javascript
while(条件表达式){  
    语句...  
}
```

（2）do while 循环

```javascript
do{  
	语句...  
}while(条件表达式)
```

​	do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，如果判断判断结果为false，则终止循环。如果判断结果为true，则继续执行循环体，依此类推

（3）for循环

```javascript
for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){  
    ③语句...  
}
```

​	首先执行①初始化表达式，初始化一个变量，然后对②条件表达式进行求值判断，如果为false则终止循环
如果判断结果为true，则执行③循环体，循环体执行完毕，执行④更新表达式，对变量进行更新。更新表达式执行完毕重复②

（4）死循环

```javascript
while(true){  

}  

for(;;){  

}
```

（5）break

​	break 语句可用于跳出循环。

​	break 语句会中断循环，并继续执行循环之后的代码（如果有）

（6）continue

​	continue 语句中断（循环中）的一个迭代，如果发生指定的条件。然后继续循环中的下一个迭代

# 对象

​	对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性，使用 typeof 检查一个对象时，会返回object

## 1.对象的分类

1.内建对象

​            \- 由ES标准中定义的对象，在任何的ES的实现中都可以使用

​            \- 比如：Math String Number Boolean Function Object….

2.宿主对象

​            \- 由 JS 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象

​            \- 比如 BOM、DOM

3.自定义对象

​            \- 由开发人员自己创建的对象 

### 1.1.创建对象

```javascript
var 对象名 = new Object();
```

### 1.2.对象的基本操作

* 添加属性

```javascript
对象.属性名 = 属性值;
obj.name = 'look';
```

* 读取属性

```javascript
对象.属性名
```

​	如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined

* 修改对象的属性

```javascript
对象.属性名 = 新值
```

* 删除对象的属性

```javascript
delete 对象.属性名
```

```javascript
var obj = new Object();
obj.name = 'look';
obj.gender = '男';
delete obj.gender;
```

### 1.3.属性名和属性值

（1）属性名

​	对象的属性名不强制要求遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写

​	如果需要使用特殊的属性名，不能采用.的方式来操作，而是如下操作

```javascript
对象["属性名"] = 属性值
obj["123"] = 456;
```

​	在 [] 中可以传递变量来操作属性

```javascript
var n = "123";
obj[n] = 789;
```

（2）属性值

​	可以是任意数据类型

（3）in 运算符

​	通过该运算符可以检查一个对象中是否含有特定的属性，如果有则返回 true，没有则返回 false

```javascript
"属性名" in 对象
console.log("123" in obj);
```

### 1.4.对象和基本数据类型

* 基本数据类型

  String Number Boolean Null  Undefined

* 引用数据类型

  Object

（1）保存

​	基本数据类型的值直接在栈内存中存储，变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。

​	对象是保存到堆内存中，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址（对象的引用）。如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。

![image-20210929144852275](C:\Users\LOOK\AppData\Roaming\Typora\typora-user-images\image-20210929144852275.png)

```javascript
var obj1 = new Object();
obj1.name = "look";
var obj2 = obj1;
obj1.name = "zjq";
console.log(obj2); // name:zjq
```

（2）比较

​	比较两个变量时，对于基本数据类型，比较的就是值;

​	对于引用数据类型比较的是地址，地址相同才相同

### 1.5.对象字面量

​	使用字面量创建对象，可以直接向对象中添加属性

​	字面量的属性名可以加引号，也可以不加，一般不加。如果要使用一些特殊的名字，则必须加引号

```javascript
var obj = {
    name: "look", 
    age: 23,
    gender: 'male'
};
```

### 1.6.方法

​	可以将一个函数设置为一个对象的属性，当一个对象的属性是一个函数时，我们称这个函数是该对象的方法。

```javascript
var obj = new Object();
    obj.name = "look";
    obj.sayName = function(){
    document.write(obj.name);
};
```

### 1.7.遍历对象属性

```javascript
var obj = {
    name:'look',
    gender:'male',
    age:'23'
};
// 每次执行时，会将对象中的属性赋值给变量n
for (var n in obj) {
	document.write(n + "<br/>");
}
```

## 2.函数

​	函数也是一个对象，也具有普通对象的功能（能有属性）

​    使用 typeof 检查一个函数时会返回 function

### 2.1.创建函数

* 将要封装的代码以字符串的形式传递给构造函数（很少使用）

```javascript
var fun1 = new Function("console.log('hello')");
```

* 函数声明

```javascript
function 函数名([形参1,形参2...形参N]){  
    语句...  
}
```

* 函数表达式

```javascript
var 函数名 = function([形参1,形参2...形参N]){  
	语句...  
};
```

### 2.2.实参

* 调用函数时 JS 解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
* 如果实参的数量大于形参，多余实参将不会赋值；如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined

* 当参数过多时，可以将参数封装到一个对象中，然后通过对象传递；实参也可以是函数

* 当实参是调用函数时，使用的是函数返回值；当实参是函数对象时，使用的是函数对象

### 2.3.返回值

​	如果 return 后不跟值，或者是不写 return 则函数默认返回 undefined

### 2.4.立即执行函数

​	函数定义完，立即被调用，这种函数叫做立即执行函数。

​	立即执行函数往往只会执行一次

```javascript
(function(a, b){
    document.write(a + b);
})(10, 46);
```

### 2.5.apply() 和 call()

​	这两个方法都是函数对象的方法，需要通过函数对象来调用。对函数调用 call() 和 apply() 都会调用函数执行。

​	在调用 call() 和 apply() 时，可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的 this。

```javascript
function fun1(){
    document.write(this + "<br/>");
}
function fun2(){
    document.write(this.name + "<br/>");
}

fun1.call(); // window
fun1.apply(); // window

var obj1 = {name:'obj1'};
var obj2 = {name:'obj2'};

fun1.call(obj1); // Object
fun1.apply(obj1); // Object
fun2.call(obj2); // obj2
```

​	call() 方法可以将实参在对象之后依次传递

​	apply() 方法需要将实参封装到一个数组中统一传递

```javascript
function fun3(a, b){
    document.write(a + '    ' + b + "<br/>");
}
fun3.call(obj1, 2, 3); // 2 3 
fun3.apply(obj1, [2, 3]); // 2 3
```

### 2.6.arguments

​	在调用函数时，浏览器每次都会传递进两个隐含的参数 —— 上下文对象 this、封装实参的对象 arguments

​	arguments 是一个类数组元素，它用来封装函数执行过程中的实参

* 通过索引来操作数据

  arguments[0] 表示第一个实参

* 获取实参个数

  arguments.length

* callee

  arguments 中有一个属性 callee 表示当前执行的函数对象

## 3.作用域

​	作用域指一个变量的作用的范围

### 3.1.全局作用域

​	直接在 script 标签中编写的代码，都运行在全局作用域中，全局作用域在打开页面时创建，在页面关闭时销毁

​	全局作用域中有一个全局对象 window，window 对象由浏览器提供，代表浏览器的窗口，在全局作用域中创建的变量都会作为 window 对象的属性保存，在全局作用域中创建的函数都会作为 window 对象的方法保存

​	全局作用域中的变量是全局变量，在页面的任意部分都可以访问

### 3.2.函数作用域

​	函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。函数作用域在函数执行时创建，在函数执行结束时销毁。在函数作用域中创建的变量，不能在全局中访问。

​	当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，直到全局作用域。

​	在函数作用域中，使用 var 关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用 var 关键字声明变量，则变量会变成全局变量。

​	在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。

​	函数的形参就相当于声明变量。

### 3.3.提前声明

（1）变量的提前声明

​	使用 var 关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值，所以我们可以在变量声明前使用变量，但是不使用 var 关键字声明的变量不会被声明提前。

（2）函数的提前声明

​	在全局作用域中，使用函数声明创建的函数（function fun(){}），会在所有的代码执行之前被创建，可以提前调用，但是使用函数表达式(var fun = function(){})创建的函数不会被声明提前，不能提前调用。

## 4.this

​	每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。使用 this 来引用上下文对象，根据函数的调用形式不同，this 的值也不同。

- 以函数的形式调用时，this 是 window
- 以方法的形式调用时，this 就是调用方法的对象
- 以构造函数的形式调用时，this 就是新创建的对象

## 5.构造函数

​	构造函数是专门用来创建对象的函数，创建方式和普通函数没有区别

```javascript
function Person(name, age, gender){
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.sayName = function(){
        document.write(this.name);
    }
}
```

​	构造函数和普通函数的调用方式不同，普通函数是直接调用，而构造函数需要 new 关键字

```javascript
var person = new Person('look', 23, 'male');
```

​	 一个构造函数也可以称为一个类，通过构造函数创建的对象，称该对象是这个构造函数的实例。通过同一个构造函数创建的对象，称为一类对象

​	构造函数的执行流程：

​          1.创建一个新的对象

​          2.将新的对象作为函数的上下文对象（this）

​          3.执行函数中的代码

​          4.将新建的对象返回



​	instanceof 用来检查一个对象是否是一个类的实例

​	语法：对象 instanceof 构造函数

​	如果该对象是构造函数的实例，则返回 true，否则返回 false

​	Object 是所有对象的祖先，所以任何对象和 Object 做 instanceof 都会返回 true

```javascript
console.log(person instanceof Person); // true
console.log(person instanceof Object); // true
```

## 6.原型（prototype）

​	创建一个函数以后，解析器都会默认在函数中添加一个属性 prototype，prototype 属性指向的是一个对象，这个对象称为原型对象。

​	如果函数作为普通函数调用 prototype 没有任何作用，当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，可以通过 对象.\_\_proto\_\_ 来访问。

```javascript
function MyClass(){
}

var mc1 = new MyClass();
var mc2 = new MyClass();

console.log(mc1.__proto__ == MyClass.prototype); // true
```

​	原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。可以将对象中共有的属性和方法统一添加到原型对象中，这样只需要添加一次，就可以使所有的对象都可以使用。

​	当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，如果在自身中找到了，则直接使用；如果没有找到，则去原型对象中寻找，如果找到了则使用，如果没有找到，则去原型的原型中寻找，依此类推。直到找到 Object 的原型为止，Object 的原型的原型为 null，如果依然没有找到则返回 undefined。

```javascript
MyClass.prototype.a = 123;
mc1.a = "a in mc";
console.log(mc1.a); // a in mc
console.log(mc2.a); // 123
```

​	使用 in 检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回 true

​	hasOwnProperty() 可以用来检查对象自身中是否含有某个属性，只有对象自身含有时，才会返回 true

```javascript
console.log("a" in mc2); // true
console.log(mc2.hasOwnProperty("a")); // false
console.log(mc1.__proto__.__proto__.hasOwnProperty("hasOwnProperty")); // true
console.log(mc1.__proto__.__proto__.__proto__); // null
```

## 7.toString()

​	直接在页面中打印一个对象时，事件上是输出的对象的 toString() 方法的返回值，toString() 在原型的原型 Object 中。如果希望在输出对象时不输出 [object Object]，可以为对象添加一个 toString() 方法

```javascript
// 修改Person原型的toString  
Person.prototype.toString = function(){  
    return "Person[name="+this.name+",age="+this.age+",gender="+this.gender+"]";  
};
console.log(person.toString()); // Person[name=look,age=23,gender=male]
```

## 8.垃圾回收（GC）

​	当一个对象没有任何的变量或属性对它进行引用，此时将永远无法操作该对象，这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。

​	在 JS 中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，不需要也不能进行垃圾回收的操作，需要做的只是要将不再使用的对象设置 null 即可。

```javascript
var obj = new Object();
obj = null;
```

# 数组

​	数组也是一个对象，是一个用来存储数据的对象，和 Object 类似，但是它的存储效率比普通对象要高

​	数组中保存的内容称为元素，数组使用索引（index）来操作元素，索引指由 0 开始的整数

## 1.数组基本操作

（1）创建数组对象

```javascript
var arr = new Array();
var arr = [1, 2, "haha", null];
```

（2）添加数组元素

​	数组中的元素可以是任意的数据类型，可以是对象、函数或数组

```javascript
arr[0] = 10;
arr[1] = 22;
arr[2] = 34;
```

（3）读取数组元素

```javascript
console.log(arr[0]);
```

（4）获取数组长度

```javascript
// length 获取到的是数组的最大索引 + 1
console.log(arr.length); // 3
```

（5）修改数组长度

​	如果修改后的 length 大于原长度，则多出的部分会空出来

​	如果修改后的 length 小于原长度，则原数组中多出的元素会被删除

```javascript
arr.length = 10;
console.log(arr); // [10, 22, 34, 空 ×7]
arr.length = 1;
console.log(arr); // [10]
```

（6）向数组最后一个位置后添加元素

```javascript
arr[arr.length] = 50;
console.log(arr); // [10, 50]
```

## 2.数组方法

### 2.1.push()

​          用来向数组的末尾添加一个或多个元素，并返回数组新的长度

​          语法：数组.push(元素1,元素2,元素N)

### 2.2.pop()

​          用来删除数组的最后一个元素，并返回被删除的元素

### 2.3.unshift()

​          向数组的开头添加一个或多个元素，并返回数组的新的长度

​          其他元素索引会依次调整

### 2.4.shift()

​          删除数组的开头的一个元素，并返回被删除的元素

### 2.5.reverse()

​          可以用来反转一个数组，它会对原数组产生影响

### 2.6.concat()

​          可以连接两个或多个数组，也可以连接元素，它不会影响原数组，而是将新数组作为返回值返回

### 2.7.forEach()

​	forEach() 方法需要一个回调函数作为参数，数组中有几个元素，回调函数就会被调用几次，每次调用时，都会将遍历到的信息以实参的形式传递进来，可以定义形参来获取这些信息。

```javascript
数组.forEach(function(value , index , obj){  
});
```

- value:正在遍历的元素
- index:正在遍历元素的索引
- obj:被遍历对象

### 2.8.slice()

​	可以从一个数组中截取指定的元素，该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 

参数： 

​	1.截取开始位置的索引（包括开始位置） 

​	2.截取结束位置的索引（不包括结束位置） 

​		第二个参数可以省略不写，如果不写则一直截取到最后 

​		参数可以传递一个负值，如果是负值，则从后往前数 

### 2.9.splice()

​	可以用来删除数组中指定元素，并使用新的元素替换 ，该方法会将删除的元素封装到新数组中返回 

参数： 

​	1.删除开始位置的索引（包括开始位置） 

​	2.删除的个数 

​	3.第三个及以后，都是替换的元素，这些元素将会插入到开始位置索引的前边 

### 2.10.join([splitor])

​	可以将一个数组转换为一个字符串，不会对原数组产生影响，而是将转换后的字符串作为结果返回
参数：
​	需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素，如果不指定连接符则默认使用 ","

### 2.11.sort()

​	可以对一个数组中的内容进行排序，默认是按照 Unicode 编码进行排序，调用以后，会直接修改原数组。

​	可以在 sort() 添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但是肯定的是在数组中 a 一定在 b 前边

​	浏览器会根据回调函数的返回值来决定元素的顺序

* 如果返回一个大于 0 的值，则元素会交换位置

* 如果返回一个小于等于 0 的值，则元素位置不变

```javascript
var arr = [1, 2, 3, 4, 5];
arr.sort(function(a, b){
    //升序排列  
	//return a - b; // 1 2 3 4 5 
	  
	//降序排列  
	return b - a; // 5 4 3 2 1
});
```

# 常用类和方法

## 1.Date

​	日期的对象，在 JS 中通过 Date 对象来表示时间

### 1.1.创建对象

创建一个当前的时间对象

```javascript
var d = new Date();
```

创建一个指定的时间对象

```javascript
var d = new Date("月/日/年 时:分:秒");
```

### 1.2.方法

* getDate()

  当前日期对象是几日（1-31）

* getDay()

  返回当前日期对象是周几（0-6），0 表示周日，1 表示周一

* getMonth()

  返回当前日期对象的月份（0-11），0 表示一月，1 表示二月

* getFullYear()

  从 Date 对象以四位数字返回年份

* getHours()

  返回 Date 对象的小时 (0 ~ 23)

* getMinutes()

  返回 Date 对象的分钟 (0 ~ 59)

* getSeconds()

  返回 Date 对象的秒数 (0 ~ 59)

* getMilliseconds()

  返回 Date 对象的毫秒(0 ~ 999)

* getTime()

  返回当前日期对象的时间戳，指的是从1970年月1日 0时0分0秒，**到现在时间的毫秒数**，计算机底层保存时间都是以时间戳的形式保存的

* Date.now()

  可以获取当前代码执行时的时间戳

## 2.Math

​	Math 属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法

* Math.PI

  常量，圆周率

* Math.abs()

  绝对值运算

* Math.ceil()

  向上取整

* Math.floor()

  向下取整

* Math.round()

  四舍五入取整

* Math.random()

  生成一个 0 1 之间的随机数
  生成一个 x y 之间的随机数

  ```javascript
  Math.round(Math.random()*(y-x)+x);
  ```

* Math.pow(x,y)

  求 x 的 y 次幂

* Math.sqrt()

  对一个数进行开方

* Math.max()

  求多个数中最大值

* Math.min()

  求多个数中的最小值

## 3.包装类

​	在 JS 中提供了三个包装类：String()、Boolean()、Number()

​	通过这三个包装类可以创建基本数据类型的对象，但是在实际应用中千万不要这么干，可能会产生不可预计的后果。

​	当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将其转换为基本数据类型，并将临时对象进行销毁。

```javascript
var num = new Number(2);  
var str = new String("hello");  
var bool = new Boolean(true);
```

## 4.字符串相关方法

​	在底层字符串是以字符数组的形式保存的

* length

  获取字符串的长度

* charAt()

  根据索引获取指定的字符

  ```javascript
  var str = "hello world";
  var result = str.charAt(2);
  document.write(result); // l
  ```

* charCodeAt()

  根据索引获取指定的字符编码（Unicode编码）

  ```javascript
  result = str.charCodeAt(2);
  document.write(result + "<br/>"); // 108
  ```

* String.fromCharCode()

  根据字符编码获取字符

  ```javascript
  result = String.fromCharCode(65);
  document.write(result + "<br/>"); // A
  ```

* indexOf() 和 lastIndexOf()

  从一个字符串中检索指定内容，需要一个字符串作为参数，这个字符串就是要检索的内容，

  如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回 -1。

  可以指定一个第二个参数，来表示开始查找的位置

  indexOf() 是从前向后找

  lastIndexOf() 是从后向前找

  ```javascript
  result = str.indexOf("o");
  document.write(result + "<br/>"); // 4
  result = str.indexOf("o", 5);
  document.write(result + "<br/>"); // 7
  result = str.lastIndexOf("o");
  document.write(result + "<br/>"); // 7
  ```

* slice()

  可以从一个字符串中截取指定的内容，并将截取的内容返回，不会影响原变量

  参数：

  第一个：截取开始的位置（包括开始位置）

  第二个：截取结束的位置（不包括结束位置）

  可以省略第二个参数，如果省略则一直截取到最后

  可以传负数，如果是负数则从后往前数

  ```javascript
  result = str.slice(1, 5);
  document.write(result + "<br/>"); // ello
  result = str.slice(1, -3);
  document.write(result + "<br/>"); // ello wo
  ```

* substring()

  和 slice() 基本一致，第一个参数是开始索引，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为 0，**substring() 中如果第二个参数小于第一个，自动交换位置**

  ```javascript
  result = str.substring(1, 5);
  document.write(result + "<br/>"); // ello
  ```

* substr()

  和slice() 基本一致，第一个参数是开始索引，不同的是它第二个参数不是索引，而是截取的数量，返回值是截取的内容，不会影响原变量

  ```javascript
  result = str.substr(0, 2);
  document.write(result + "<br/>"); // he
  ```

* toLowerCase()

  将字符串转换为小写并返回

* toUpperCase()

  将字符串转换为大写并返回

* split()

  可以根据指定内容将一个字符串拆分为一个数组，需要一个字符串作为参数，将会根据字符串去拆分数组

  如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素

  ```javascript
  str = "ab, cd, ef, g";
  result = str.split(",");
  document.write(result + "<br/>"); // ab, cd, ef, g
  result = str.split("d");
  document.write(result + "<br/>"); // ab, c,, ef, g
  result = str.split("");
  document.write(result + "<br/>"); // a,b,,, ,c,d,,, ,e,f,,, ,g
  ```
  
  可以接收一个正则表达式，此时会根据正则表达式去拆分数组
  
  ```javascript
  str = "1sadf2we3fdg4vc56";
  result = str.split(/[A-z]/);
  document.write(result + "<br/>"); // 1,,,,2,,3,,,4,,56
  ```

# 正则表达式

## 1.创建正则表达式

```javascript
var reg = new RegExp(“正则表达式”,”匹配模式”);
var reg = /正则表达式/匹配模式; // （匹配模式可以多个一起写：/gi）
```

​	使用 typeof 检查正则对象，会返回 object

可以设置第二个参数匹配模式：

​	i:忽略大小写（ignore）

​	g:全局匹配模式（默认为1次）

​	设置匹配模式时，可以都不设置，也可以设置 1 个，也可以全设置，设置时没有顺序要求

## 2.test()

​	可以用来检查一个字符串是否符合正则表达式，如果符合返回 true，否则返回 false

```javascript
var reg = new RegExp("a");
var str = "a";
var result = reg.test(str);
document.write(result + "<br/>"); // true
reg = /a/i;
result = reg.test(str);
document.write(result + "<br/>"); // true
```

## 3.正则表达式

### 3.1.基本语法

​		| 或

​        [] 或

​        \[^ \] 除了

​        [a-z] 小写字母

​        [A-Z] 大写字母

​        [A-z] 任意字母

​        [0-9] 任意数字

```javascript
// 字符串中存在a或b
reg = /a|b/;
reg = /[ab]/; 

// 字符串中存在abc或adc或aec
reg = /a[bde]c/;
```

​	. 表示任意字符，在正则表达式中使用 \ 作为转义字符，\\\. 来表示 .，\\\\ 表示 \

\w

​	任意字母、数字、_，相当于 [A-z0-9_]

\W

​	除了字母、数字、_，相当于 [^A-z0-9_]

\d

​	任意的数字 [0-9]

\D

​	除了数字 [ ^0-9]

\s

​	空格

\S

​	除了空格

\b

​	单词边界

\B

​	除了单词边界

```javascript
// 检查是否含有child
var reg = /child/;
var str = "children";
document.write(reg.test(str) + "<br/>"); // true
reg = /\bchild\b/;
document.write(reg.test(str) + "<br/>"); // false
```

```javascript
var str = "   he  llo    ";
// 去除开头的空格
str = str.replace(/^\s*/, "");
// 去除结尾的空格
str = str.replace(/\s*$/, "");
// 去除开头和结尾的空格
str = str.replace(/^\s*|\s*$/g, "");
```

```javascript
// 电子邮件
var emailReg = /^\w{3, }(\.\w+)*@[A-z0-9]+(\.[A-z]{2, 5}){1, 2}$/;
```

### 3.2.量词

​	通过量词可以设置一个内容出现的次数，量词只对它前边的一个内容起作用

​          {n} 正好出现 n 次

​          {m, n} 出现 m ~ n 次

​          {m, } m 次及以上

​          \+ 至少一个，相当于 {1, }

​          \* 0 个或多个，相当于 {0, }  

​          ? 0 个或 1 个，相当于 {0, 1}

```javascript
var reg = /a{3}/; // aaa
reg = /(ab){3}/; // ababab
reg = /ab+c/;
```

### 3.3.边界表达式

​	^ 表示开始

​	$ 表示结尾

```javascript
reg = /^a/; // 匹配开头的a
reg = /a$/; // 匹配结尾的a
```

手机号的规则

​	1.以1开头

​	2.第二位3~9任意数字

​	3.第三位及以后任意数字9个

```javascript
var phoneReg = /^1[3-9][0-9]{9}$/;
```

## 4.字符串和正则表达式相关的方法

### 4.1.search()

​	可以搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回 -1。它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串

​	serach() 只会查找第一个，即使设置全局匹配也没用

```javascript
var result = str.search(/a[bde]c/);
```

### 4.2.match()

​	可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，默认情况下 match() 只会找到第一个符合要求的内容，找到以后就停止检索，可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，可以为一个正则表达式设置多个匹配模式，且顺序无所谓

​	match() 会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果

```javascript
str = "1a2b3c4d5e6f7A8B";
result = str.match(/[a-z]/);
document.write(result + "<br/>"); // a
result = str.match(/[a-z]/ig);
document.write(result + "<br/>"); // a,b,c,d,e,f,A,B
```

### 4.3.replace()

​	可以将字符串中指定内容替换为新的内容

参数：

​	1.被替换的内容，可以接受一个正则表达式作为参数

​	2.新的内容若是空串则为删除""

​	默认只会替换第一个

```javascript
str = "1a2a3a4a5a6a";
result = str.replace(/a/g, "");
document.write(result + "<br/>"); // 123456
```

# DOM

## 1.简介

​	Document Object Model，即文档对象模型，通过 DOM 可以来任意来修改网页中各个内容

* 文档

文档指的是网页，一个网页就是一个文档

* 对象

对象指将网页中的每一个节点都转换为对象，转换完对象以后，就可以以一种纯面向对象的形式来操作网页了

* 模型

模型用来表示节点和节点之间的关系，方便操作页面

* 节点（Node）

节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点，虽然都是节点，但是节点的类型却是不同的

​	（1）文档节点 （Document），代表整个网页

​	（2）元素节点（Element），代表网页中的标签

​	（3）属性节点（Attribute），代表标签中的属性

​	（4）文本节点（Text），代表网页中的文本内容

![image-20211001212628871](C:\Users\LOOK\AppData\Roaming\Typora\typora-user-images\image-20211001212628871.png)

## 2.事件

​	事件指的是用户和浏览器之间的交互行为，比如：点击按钮、关闭窗口、鼠标移动等，可以为事件来绑定回调函数来响应事件。

```html
<body>
    <button id="btn">我是一个按钮</button>
    <script type="text/javascript">
        var btn = document.getElementById("btn");
        btn.onclick = function(){
        	alert('点击按钮');
        }
    </script>
</body>
```

![image-20211001214857803](C:\Users\LOOK\AppData\Roaming\Typora\typora-user-images\image-20211001214857803.png)

window.onload 对应的回调函数会在整个页面加载完毕以后才执行

## 3.DOM操作

### 3.1.获取元素节点

根据元素的 id 属性查询一个元素节点对象：

```javascript
document.getElementById(“id属性值”);
```

根据元素的 name 属性值查询一组元素节点对象，返回一个类数组对象：

```
document.getElementsByName(“name属性值”);
```

根据标签名来查询一组元素节点对象：

```javascript
document.getElementsByTagName(“标签名”);
```

### 3.2.读取元素属性

```javascript
元素.属性名
ele.id
ele.value
ele.nodeValue
```

注意：class 属性不能采用这种方式，读取 class 属性时需要使用

```javascript
元素.className
```

​	innerHTML，使用该属性可以获取或设置元素内部的 HTML 代码

​	innerHTML 和 innerText，这两个属性并没有在 DOM 标准定义，但是大部分浏览器都支持这两个属性，两个属性作用类似，都可以获取到标签内部的内容。

​	**不同是 innerHTML 会获取到 html 标签，而 innerText 会自动去除标签**，如果使用这两个属性来设置标签内部的内容时，没有任何区别。

### 3.3.获取元素节点的子节点

​	**子节点包括标签元素中的文本，子元素自包含标签元素**

（1）通过具体的元素节点来查询，元素.getElementsByTagName()，通过标签名查询当前元素的指定后代元素

```javascript
//获取id为city的元素
var city = document.getElementById("city");
//查找#city下所有li节点
var lis = city.getElementsByTagName("li");
```

（2）元素.childNodes

获取当前元素的**所有子节点**，**会获取到空白的文本子节点**，在 IE8 及以下的浏览器中，不会将空白文本当成子节点。

```javascript
//获取id为city的节点
var city = document.getElementById("city");
//返回#city的所有子节点
var cns = city.childNodes;
```

（3）元素.children
获取当前元素的**所有子元素**

```javascript
var cns2 = city.children;
```

（4）元素.firstChild

获取当前元素的**第一个子节点**，会获取到空白的文本子节点

```javascript
//获取id为phone的元素
var phone = document.getElementById("phone");
//firstChild可以获取到当前元素的第一个子节点（包括空白文本节点）
var fir = phone.firstChild;
```

（5）firstElementChild 获取当前元素的第一个子元素，firstElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用

```javascript
var phone = document.getElementById("phone");
var fir = phone.firstElementChild;
```

（6）元素.lastChild

获取当前元素的**最后一个子节点**

（7）元素.parentNode

获取当前元素的父元素

```javascript
//获取id为bj的节点
var bj = document.getElementById("bj");
//返回#bj的父节点
var pn = bj.parentNode;
```

（8）元素.previousSibling

获取当前元素的前一个兄弟节点（可能获取到空白的文本），previousElementSibling 获取前一个兄弟元素，IE8及以下不支持

```javascript
//获取id为android的元素
var and = document.getElementById("android");
//返回#android的前一个兄弟节点（也可能获取到空白的文本）
var ps = and.previousSibling;
//previousElementSibling获取前一个兄弟元素，IE8及以下不支持
var pe = and.previousElementSibling;
```

（9）元素.nextSibling

获取当前元素的后一个兄弟节点

### 3.4.dom 查询的其他方法

（1）document.all

**获取页面中的所有元素**，相当于

```javascript
document.getElementsByTagName(“*”);
```

（2）document.documentElement

**获取页面中 html 根元素**

（3）document.body

获取页面中的 body 元素

（4）document.getElementsByClassName()

**根据元素的 class 属性值查询一组元素节点对象**，这个方法不支持 IE8 及以下的浏览器

（5）document.querySelector()

**根据 CSS 选择器去页面中查询一个元素**，如果匹配到的元素有多个，则它会返回查询到的第一个元素

（6）document.querySelectorAll()

根据 CSS 选择器去页面中查询一组元素，会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个

### 3.5.增删改

（1）document.createElement(“TagName”)

​	可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回

（2）document.createTextNode(“textContent”)

​	可以根据文本内容创建一个文本节点对象

（3）**父节点.appendChild(子节点)**

​	向父节点中添加指定的子节点

（4）**父节点.insertBefore(新节点,旧节点)**

​	将一个新的节点插入到旧节点的前边

（5）父节点.replaceChild(新节点,旧节点)

​	使用一个新的节点去替换旧节点

（6）**父节点.removeChild(子节点)**

​	删除指定的子节点

推荐方式：**子节点.parentNode.removeChild(子节点)**



**以上方法，实际就是改变了相应元素（标签）的innerHTML的值。**

### 3.6.对 CSS 的操作

#### 3.6.1.内联样式

（1）读取内联样式

语法：元素.style.样式名

**如果样式名中带有 -，则需要将样式名修改为驼峰命名法将 - 去掉，然后后面的字母改大写**

比如 backgroundcolor ---> backgroundColor、borderwidth ---> borderWidth

（2）修改内联样式

语法：元素.style.样式名 = 样式值

```javascript
var box1 = document.getElementById("box1");
box1.style.width = "300px";
box1.style.height = "300px";
box1.style.backgroundColor = "yellow";
```

​	**通过 style 修改和读取的样式都是内联样式**，由于内联样式的优先级比较高，所以我们通过 JS 来修改的样式，往往会立即生效，**但是如果样式中设置了 !important，则内联样式将不会生效。**

#### 3.6.2.当前样式

（1）正常浏览器（不支持 IE8 及以下的浏览器）

​	** 使用getComputedStyle() **，这个方法是 window 对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式

参数：

​	1.要获取样式的元素

​	2.可以传递一个伪元素，一般传 null

例子：

​	获取元素的宽度

```javascript
var box1 = document.getElementById("box1");
getComputedStyle(box1, null).width;
```

​	通过该方法读取到样式都是只读的不能修改，如果要修改必须通过 style 属性。如果获取的样式没有设置，则会获取到真实的值，而不是默认值，比如没有设置 width，它不会获取到 auto，而是一个真实长度。

（2）IE8

​	**使用currentStyle**

语法：元素.currentStyle.样式名

例子：

```javascript
box1.currentStyle.width
```

​	通过这个属性读取到的样式是只读的不能修改，如果要修改必须通过 style 属性

（3）解决兼容性问题

```javascript
/*
* 定义一个函数，用来获取指定元素的当前的样式
* 参数：
* 		obj 要获取样式的元素
* 		name 要获取的样式名
*/
function getStyle(obj , name){

    if(window.getComputedStyle){
        //正常浏览器的方式，具有getComputedStyle()方法
        return getComputedStyle(obj , null)[name];
    }else{
        //IE8的方式，没有getComputedStyle()方法
        return obj.currentStyle[name];
    }
}
```

#### 3.6.3.其他的样式相关的属性

注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角

（1）clientHeight

​	元素的可见高度，包括元素的内容区和内边距的高度

（2）clientWidth

​	元素的可见宽度，包括元素的内容区和内边距的宽度

（3）offsetHeight

​	整个元素的高度，包括内容区、内边距、边框

（4）offfsetWidth

​	整个元素的宽度，包括内容区、内边距、边框

（5）offsetParent

​	当前元素的定位父元素

​	离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回 body

（6）offsetLeft

​	当前元素相对于其定位父元素之间的水平偏移量

（7）offsetTop

​	当前元素相对于其定位父元素之间的垂直偏移量

（8）scrollHeight

​	获取元素滚动区域的高度

（9）scrollWidth

​	获取元素滚动区域的宽度

（10）scrollTop

​	获取元素垂直滚动条滚动的距离

（11）scrollLeft

​	获取元素水平滚动条滚动的距离

（12）判断滚动条是否滚动到底

​	垂直滚动条

```javascript
scrollHeight - scrollTop == clientHeight
```

​	水平滚动

```javascript
scrollWidth - scrollLeft == clientWidth
```

# 事件

## 1.事件对象

​	当事件的响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向等

​	可以在响应函数中定义一个形参，来使用事件对象，但是在 IE8 及以下浏览器中事件对象没有做完实参传递，而是作为 window 对象的属性保存

```javascript
元素.事件 = function(event){  
    event = event || window.event;  
};  
```

​	**获取到鼠标的坐标**

clientX 和 clientY 用于获取鼠标在当前的可见窗口的坐标

```javascript
var x = event.clientX;
var y = event.clientY;
```

​	pageX 和 pageY 可以获取鼠标相对于当前页面的坐标，但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用

## 2.冒泡

​	事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的相同事件也会触发。事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消。

​	**可以将事件对象的cancelBubble设置为true，即可取消冒泡**

```javascript
元素.事件 = function(event){  
    event = event || window.event;  
    event.cancelBubble = true;  
};
```

## 3.事件的委派

​	指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而

通过祖先元素的响应函数来处理事件。

​	事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能。

​	我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的，可以尝试将其绑定给元素的共

同的祖先元素。

**target** : event 中的 target 表示的触发事件的对象

## 4.事件的绑定

### 4.1.addEventListener()

​	通过这个方法可以为元素绑定响应函数，方法中的 this 是绑定事件的对象

参数：

​	1.事件的字符串，不要 on

​	2.回调函数，当事件触发时该函数会被调用

​	3.是否在捕获阶段触发事件，需要一个布尔值，一般都传 false

​	使用 addEventListener() 可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行。这个方法不支持IE8及以下的浏览器。

```javascript
btn01.addEventListener("click",function(){  
	alert(1);  
},false);  
  
btn01.addEventListener("click",function(){  
	alert(2);  
},false);
```

### 4.2.attachEvent()

​	在 IE8 中可以使用 attachEvent() 来绑定事件，方法中的 this 是 window

参数：

​	1.事件的字符串，要 on

​	2.回调函数

​	这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是后绑定先执行，执行顺序和addEventListener() 相反。

```javascript
btn01.attachEvent("onclick",function(){  
	alert(1);  
});  
  
btn01.attachEvent("onclick",function(){  
	alert(2);  
});
```

### 4.3.定义一个函数，用来为指定元素绑定响应函数

参数：

​       \* obj 要绑定事件的对象

​       \* eventStr 事件的字符串(不要 on)

​       \* callback 回调函数

```javascript
function bind(obj , eventStr , callback){
    if(obj.addEventListener){
        //大部分浏览器兼容的方式
        obj.addEventListener(eventStr , callback , false);
    }else{
        /*
		* this是谁由调用方式决定
		* callback.call(obj)
		*/
        //IE8及以下
        obj.attachEvent("on"+eventStr , function(){
            //在匿名函数中调用回调函数
            callback.call(obj);
        });
    }
}
```

## 5.事件的传播

​	关于事件的传播网景公司和微软公司有不同的理解

（1）微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。

（2）网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素。

（3）W3C 综合了两个公司的方案，将事件传播分成了三个阶段

* 捕获阶段

​	在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件

* 目标阶段

​	事件捕获到目标元素，捕获结束开始在目标元素上触发事件

* 冒泡阶段

​	事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件

![image-20211003142147635](C:\Users\LOOK\AppData\Roaming\Typora\typora-user-images\image-20211003142147635.png)

​	如果希望在捕获阶段就触发事件，可以将 addEventListener() 的第三个参数设置为 true，一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是 false

## 6.常用事件

### 6.1.鼠标事件

#### 6.1.1.拖拽事件

* onmousedown

  当鼠标在被拖拽元素上按下时

* onmousemove

  当鼠标移动时被拖拽元素跟随鼠标移动

* onmouseup

  当鼠标松开时

* setCapture() 或 setCapture

  当调用一个元素的 setCapture() 方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上

* releaseCapture() 或 releaseCapture

  取消对事件的捕获

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			#box1{
				width: 100px;
				height: 100px;
				background-color: red;
				position: absolute;
			}
			#box2{
				width: 100px;
				height: 100px;
				background-color: yellow;
				position: absolute;
				
				left: 200px;
				top: 200px;
			}
		</style>
		<script type="text/javascript">
			window.onload = function(){
				/*
				 * 拖拽box1元素
				 *  - 拖拽的流程
				 * 		1.当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown
				 * 		2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove
				 * 		3.当鼠标松开时，被拖拽元素固定在当前位置	onmouseup
				 */
				//获取box1
				var box1 = document.getElementById("box1");
				var box2 = document.getElementById("box2");
				//为box1绑定一个鼠标按下事件
				//当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown
				box1.onmousedown = function(event){
					//设置box1捕获所有鼠标按下的事件
					/*
					 * setCapture()
					 * 	- 只有IE支持，但是在火狐中调用时不会报错，
					 * 		而如果使用chrome调用，会报错
					 */
					/*if(box1.setCapture){
						box1.setCapture();
					}*/
					box1.setCapture && box1.setCapture();
					event = event || window.event;
					//div的偏移量 鼠标.clentX - 元素.offsetLeft
					//div的偏移量 鼠标.clentY - 元素.offsetTop
					var ol = event.clientX - box1.offsetLeft;
					var ot = event.clientY - box1.offsetTop;
					
					//为document绑定一个onmousemove事件
					document.onmousemove = function(event){
						event = event || window.event;
						//当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove
						//获取鼠标的坐标
						var left = event.clientX - ol;
						var top = event.clientY - ot;
						
						//修改box1的位置
						box1.style.left = left+"px";
						box1.style.top = top+"px";
					};
					
					//为document绑定一个鼠标松开事件
					document.onmouseup = function(){
						//当鼠标松开时，被拖拽元素固定在当前位置	onmouseup
						//取消document的onmousemove事件
						document.onmousemove = null;
						//取消document的onmouseup事件
						document.onmouseup = null;
						//当鼠标松开时，取消对事件的捕获
						box1.releaseCapture && box1.releaseCapture();
					};
					
					/*
					 * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，
					 * 	此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，
					 * 	如果不希望发生这个行为，则可以通过return false来取消默认行为
					 * 
					 * 但是这招对IE8不起作用
					 */
					return false;
				};
			};
		</script>
	</head>
	<body>
		我是一段文字
		<div id="box1"></div>
		<div id="box2"></div>
	</body>
</html>
```

#### 6.1.2.滚轮事件

* onmousewheel

  鼠标滚轮滚动的事件，会在滚轮滚动时触发，但是火狐不支持该属性

* DOMMouseScroll

  在火狐中需要使用 DOMMouseScroll 来绑定滚动事件，注意该事件需要通过 addEventListener() 函数来绑定

* event.wheelDelta

  可以获取鼠标滚轮滚动的方向，向上滚 120  向下滚 -120，wheelDelta 这个值我们不看大小，只看正负

* event.detail

  在火狐中使用 event.detail 来获取滚动的方向，向上滚 -3 ，向下滚 3

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			#box1{
				width: 100px;
				height: 100px;
				background-color: red;
			}
		</style>
		<script type="text/javascript">
			window.onload = function(){
				
				//获取id为box1的div
				var box1 = document.getElementById("box1");
				
				//为box1绑定一个鼠标滚轮滚动的事件
				/*
				 * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，
				 * 	但是火狐不支持该属性
				 * 
				 * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件
				 * 	注意该事件需要通过addEventListener()函数来绑定
				 */
				box1.onmousewheel = function(event){
					
					event = event || window.event;
					
					//event.wheelDelta 可以获取鼠标滚轮滚动的方向
					//向上滚 120   向下滚 -120
					//wheelDelta这个值我们不看大小，只看正负
					
					//alert(event.wheelDelta);
					
					//wheelDelta这个属性火狐中不支持
					//在火狐中使用event.detail来获取滚动的方向
					//向上滚 -3  向下滚 3
					//alert(event.detail);
					
					/*
					 * 当鼠标滚轮向下滚动时，box1变长
					 * 	当滚轮向上滚动时，box1变短
					 */
					//判断鼠标滚轮滚动的方向
					if(event.wheelDelta > 0 || event.detail < 0){
						//向上滚，box1变短
						box1.style.height = box1.clientHeight - 10 + "px";
						
					}else{
						//向下滚，box1变长
						box1.style.height = box1.clientHeight + 10 + "px";
					}
					
					/*
					 * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false
					 * 需要使用event来取消默认行为event.preventDefault();
					 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错
					 */
					event.preventDefault && event.preventDefault();
					
					/*
					 * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，
					 * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为
					 */
					return false;
				};
				//为火狐绑定滚轮事件
				bind(box1,"DOMMouseScroll",box1.onmousewheel);
			};
			
			function bind(obj , eventStr , callback){
				if(obj.addEventListener){
					//大部分浏览器兼容的方式
					obj.addEventListener(eventStr , callback , false);
				}else{
					/*
					 * this是谁由调用方式决定
					 * callback.call(obj)
					 */
					//IE8及以下
					obj.attachEvent("on"+eventStr , function(){
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
				}
			}
		</script>
	</head>
	<body style="height: 2000px;">
		<div id="box1"></div>
	</body>
</html>
```

### 6.2.键盘事件

* onkeydown

  按键被按下，对于 onkeydown 来说如果一直按着某个按键不松手，则事件会一直触发，当 onkeydown 连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。

* onkeyup

  按键被松开

* keyCode

  可以通过keyCode来获取按键的编码，通过它可以判断哪个按键被按下

* 除了 keyCode，事件对象中还提供了几个属性 altKey、ctrlKey、shiftKey 这个三个用来判断 alt、ctrl 和 shift是否被按下，如果按下则返回 true，否则返回 false。

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function(){
				/*
				 * 键盘事件：
				 * 	onkeydown
				 * 		- 按键被按下
				 * 		- 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发
				 * 		- 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快
				 * 			这种设计是为了防止误操作的发生。
				 * 	onkeyup
				 * 		- 按键被松开
				 * 
				 *  键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document
				 */
				document.onkeydown = function(event){
					event = event || window.event;
					/*
					 * 可以通过keyCode来获取按键的编码
					 * 	通过它可以判断哪个按键被按下
					 * 除了keyCode，事件对象中还提供了几个属性
					 * 	altKey
					 * 	ctrlKey
					 * 	shiftKey
					 * 		- 这个三个用来判断alt ctrl 和 shift是否被按下
					 * 			如果按下则返回true，否则返回false
					 */
					//console.log(event.keyCode);
					//判断一个y是否被按下
					//判断y和ctrl是否同时被按下
					if(event.keyCode === 89 && event.ctrlKey){
						console.log("ctrl和y都被按下了");
					}
				};
				document.onkeyup = function(){
					console.log("按键松开了");
				};
				
				//获取input
				var input = document.getElementsByTagName("input")[0];
				
				input.onkeydown = function(event){
					event = event || window.event;
					//console.log(event.keyCode);
					//数字 48 - 57
					//使文本框中不能输入数字
					if(event.keyCode >= 48 && event.keyCode <= 57){
						//在文本框中输入内容，属于onkeydown的默认行为
						//如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中
						return false;
					}
				};
			};
		</script>
	</head>
	<body>
		<input type="text" />
	</body>
</html>
```

# BOM

​	浏览器对象模型(browser object model)，BOM 可以使我们通过JS来操作浏览器，在 BOM 中为我们提供了一组对象，用来完成对浏览器的操作

* Window

  代表的是整个浏览器的窗口，同时 window 也是网页中的全局对象

* Navigator

  代表当前浏览器的信息，通过该对象可以来识别不同的浏览器

* Location

  代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面

* History

  代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效

* Screen

  代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息



​	这些 BOM 对象在浏览器中都是作为 window 对象的属性保存的，可以通过 window 对象来使用，也可以直接使用

## 1.Navigator

​	代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器，由于历史原因，Navigator 对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用 **userAgent** 来判断浏览器的信息。

​	**userAgent** 是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent。

（1）火狐的 userAgent

​	Mozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 Firefox50.0

（2）Chrome 的 userAgent

​	Mozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) Chrome52.0.2743.82 Safari537.36

（3）IE8 的 userAgent

​	Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)

（4）IE9 的 userAgent

​	Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)

（5）IE10 的 userAgent

​	Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)

（6）IE11 的 userAgent

​	Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko

​	在 IE11 中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过 userAgent 来识别一个浏览器是否是 IE 了。

```javascript
var ua = navigator.userAgent;

if(/firefox/i.test(ua)){
    alert("你是火狐！！！");
}else if(/chrome/i.test(ua)){
    alert("你是Chrome");
}else if(/msie/i.test(ua)){
    alert("你是IE浏览器~~~");
}else if("ActiveXObject" in window){
    alert("你是IE11，枪毙了你~~~");
}
```

​	如果通过 userAgent 不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息，比如ActiveXObject

```javascript
if("ActiveXObject" in window){
    alert("你是IE，我已经抓住你了~~~");
}else{	
    alert("你不是IE~~~");
}
```

## 2.History

​	对象可以用来操作浏览器向前或向后翻页。

* length

  属性，可以获取到当前访问的链接数量

* back()

  可以用来回退到上一个页面，作用和浏览器的回退按钮一样

* forward()

  可以跳转下一个页面，作用和浏览器的前进按钮一样

* go()

  可以用来跳转到指定的页面，它需要一个整数作为参数，1 表示向前跳转一个页面，相当于forward()，2 表示向前跳转两个页面，-1 表示向后跳转一个页面，-2 表示向后跳转两个页面

```javascript
history.length
history.back();
history.forward();
history.go(-2);
```

## 3.Location

​	该对象中封装了浏览器的地址栏的信息，如果直接打印 location，则可以获取到地址栏的信息（当前页面的完整路径）

```javascript
alert(location);
```

​	如果直接将 location 属性修改为一个完整的路径，或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录

```javascript
location = “http:[www.baidu.com"](http://www.baidu.com"/);
location = “01.BOM.html”;
```

* assign()

  用来跳转到其他的页面，作用和直接修改 location 一样

  ```javascript
  location.assign("http://www.baidu.com");
  ```

* reload()

  用于重新加载当前页面，作用和刷新按钮一样，如果在方法中传递一个 true，作为参数，则会强制清空缓存刷新页面

  ```javascript
  location.reload(true);
  ```

* replace()

  可以使用一个新的页面替换当前页面，调用完毕也会跳转页面，不会生成历史记录，不能使用回退按钮回退

```javascript
location.replace("http://www.baidu.com");
```

## 4.window

### 4.1.定时器

#### 4.1.1.**setInterval()**

​	定时调用，可以指定一个函数每隔一段时间执行一次

参数：

​	1.回调函数，该函数会每隔一段时间被调用一次

​	2.每次调用间隔的时间，单位是毫秒

返回值：

​	返回一个 Number 类型的数据，这个数字用来作为定时器的唯一标识

#### 4.1.2.**clearInterval()**

​	**可以用来关闭一个定时器**，方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器

​	clearInterval()可以接收任意参数，如果参数是一个有效的定时器的标识，则停止对应的定时器；如果参数不是一个有效的标识，则什么也不做。

```javascript
var timer = setInterval(function(){
    count.innerHTML = num++;
    if(num == 11){
        //关闭定时器
        clearInterval(timer);
    }
},1000);
```

### 4.2.延时调用

​	**setTimeout()**

​	延时调用的回调函数不马上执行，而是隔一段时间以后再执行，而且只会执行一次

```javascript
var timer = setTimeout(function(){
    console.log(num++);
},3000);
// 使用clearTimeout()来关闭一个延时调用
clearTimeout(timer);
```































